---
title: "Working with a single data frame"
subtitle: "<br><br> Data Science & Statistics"
author: "Gavin McNicol"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    self_contained: true
    lib_dir: libs
    nature:
      ratio: "16:9"
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r packages, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
```

class: middle

# .hand[We...]

.huge[.green[have]] .hand[a single data frame]

.huge[.pink[want]] .hand[to slice it, and dice it, and juice it, and process it]

---

## Data: Commercial Fish Production In The Great Lakes 1867-2015

- Data on annual fish catch (weight in lbs) from the Great Lakes (Superior, Michigan, Huron, Erie, and Ontario)
- Observations: Each row represents the annual catch for a particular species

```{r load-data, message = FALSE, warning = FALSE}
catch_data <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-06-08/fishing.csv')
```

---

class: middle

# `select`, `arrange`, and `slice`

---

## `select` to keep variables

```{r}
catch_data %>%
  select(year, values) #<<
```

---

## `select` to exclude variables

.small[
```{r output.lines=18}
catch_data %>%
  select(-year) #<<
```
]

---

## `select` a range of variables

```{r}
catch_data %>%
  select(year:grand_total) #<<
```

---

## `select` variables with certain characteristics

```{r}
catch_data %>%
  select(starts_with("reg")) #<<
```

---

## `select` variables with certain characteristics

```{r}
catch_data %>%
  select(ends_with("es")) #<<
```

---

## `select` variables with certain characteristics

```{r}
catch_data %>%
  select(contains("u")) #<<
```

---

## `select` **all** variables

```{r}
catch_data %>%
  select(everything()) #<<
```

---

## Select helpers

- `starts_with()`: Starts with a prefix
- `ends_with()`: Ends with a suffix
- `contains()`: Contains a literal string
- `num_range()`: Matches a numerical range like x01, x02, x03
- `one_of()`: Matches variable names in a character vector
- `everything()`: Matches all variables
- `last_col()`: Select last variable, possibly with an offset
- `matches()`: Matches a regular expression (a sequence of symbols/characters expressing a string/pattern to be searched for within text)

.footnote[
See help for any of these functions for more info, e.g. `?everything`.
]

---

## `arrange` in ascending / descending order

.pull-left[
```{r}
catch_data %>%
  select(year, region, values) %>%
  arrange(values) #<<
```
]
.pull-right[
```{r}
catch_data %>%
  select(year, region, values) %>%
  arrange(desc(values)) #<<
```
]

---

## `slice` for certain row numbers

.midi[
```{r output.lines=17}
# first five
catch_data %>%
  slice(1:5) #<<
```
]

---

.tip[
In R, you can use the `#` for adding comments to your code. 
Any text following `#` will be printed as is, and won't be run as R code.
This is useful for leaving comments in your code and for temporarily disabling 
certain lines of code while debugging.
]

.small[
```{r output.lines=10}
catch_data %>%
  # slice the first five rows  # this line is a comment
  #select(hotel) %>%           # this one doesn't run
  slice(1:5)                   # this line runs
```
]

---

class: middle

# `filter`

---

## `filter` to select a subset of rows

.midi[
```{r output.lines=17}
# catches for Lake Huron
catch_data %>%
  filter(lake == "Huron") #<<
```
]

---

## `filter` for many conditions at once

```{r}
# large catches in Lake Huron
catch_data %>%
  filter(
    lake == "Huron",   #<<
    values > 100,     #<<
    ) %>% 
  select(year, lake, values)
```

---

## `filter` for more complex conditions

```{r}
# small but non-zero catches for Lake Huron and Lake Superior
catch_data %>%
  filter( 
    lake == "Huron" | lake == "Superior",     
    values > 0 & values < 100     # & means "AND" (| means "OR")  #<<
    ) %>%
  select(year, lake, values)
```

---

## Logical operators in R

<br>

operator    | definition                   || operator     | definition
------------|------------------------------||--------------|----------------
`<`         | less than                    ||`x`&nbsp;&#124;&nbsp;`y`     | `x` OR `y` 
`<=`        |	less than or equal to        ||`is.na(x)`    | test if `x` is `NA`
`>`         | greater than                 ||`!is.na(x)`   | test if `x` is not `NA`
`>=`        |	greater than or equal to     ||`x %in% y`    | test if `x` is in `y`
`==`        |	exactly equal to             ||`!(x %in% y)` | test if `x` is not in `y`
`!=`        |	not equal to                 ||`!x`          | not `x`
`x & y`     | `x` AND `y`                  ||              |

---

.your-turn[
### Your turn!

Time to actually play around with the Great Lake Catches dataset!

- Go to GitHub and clone `e-04-great-lakes-catches` into RStudio
- Open the R Markdown document and complete Exercises 1 - 4.
]

---

class: middle

# `distinct` and `count`

---

```{r include=FALSE}
options(dplyr.print_max = 20)
```


## `distinct` to filter for unique rows

... and `arrange` to order alphabetically

.small[
.pull-left[
```{r}
catch_data %>% 
  distinct(region) %>% #<<
  arrange(region)
```
]
.pull-right[
```{r output.lines=13}
catch_data %>% 
  distinct(year, region) %>% #<<
  arrange(year, region)
```
]
]

---

## `count` to create frequency tables

.pull-left[
```{r}
# alphabetical order by default
catch_data %>%
  count(region) #<<
```
]
--
.pull-right[
```{r}
# descending frequency order
catch_data %>%
  count(region, sort = TRUE) #<<
```
]

---

## `count` and `arrange`

.pull-left[
```{r}
# ascending frequency order
catch_data %>%
  count(region) %>%
  arrange(n) #<<
```
]
.pull-right[
```{r}
# descending frequency order
# just like adding sort = TRUE
catch_data %>%
  count(region) %>%
  arrange(desc(n)) #<<
```
]

---

## `count` for multiple variables

```{r}
catch_data %>%
  count(year, region) #<<
```

---

## order matters when you `count`

.midi[
.pull-left[
```{r}
# year first
catch_data %>%
  count(year, region) #<<
```
]
.pull-right[
```{r}
# region first
catch_data %>%
  count(region, year) #<<
```
]
]

---

.your-turn[
### Your turn!

- Go back to RStudio Cloud and continue `e-04-great-lakes-catches`.
- Open the R Markdown document and complete Exercises 5 and 6.
]

---

class: middle

# `mutate`

---

## `mutate` to add a new variable

```{r}
catch_data %>%
  mutate(catch_fraction =  values / grand_total) %>% #<<
  select(values, grand_total, catch_fraction) %>%
  arrange(desc(catch_fraction))
```

---

## Catch fraction for specific Lake

.midi[
.pull-left[
```{r}
# Lake Michigan
catch_data %>%
  mutate(catch_fraction =  values / grand_total) %>%
  filter(
    catch_fraction >= 0.3,
    lake == "Michigan"
    ) %>%
  select(lake, region, catch_fraction)
```
]
.pull-right[
```{r}
# Lake Erie
catch_data %>%
  mutate(catch_fraction =  values / grand_total) %>%
  filter(
    catch_fraction >= 0.3,
    lake == "Erie"
    )  %>%
  select(lake, region, catch_fraction)
```
]
]

---

.question[
What is happening in the following chunk?
]

.midi[
```{r}
catch_data %>%
  mutate(catch_fraction =  values / grand_total) %>%
  count(region, catch_fraction) %>%
  mutate(prop = n / sum(n))
```
]

---

class: middle

# `summarise` and `group_by`

---

## `summarise` for summary stats

```{r}
# mean annual catch
catch_data %>%
  summarise(mean_catch = mean(values, na.rm = T)) #<<
```

--

.pull-left-wide[
.tip[
`summarise()` changes the data frame entirely, it collapses rows down to a single 
summary statistic, and removes all columns that are irrelevant to the calculation.
]
]

---

.tip[
`summarise()` also lets you get away with being sloppy and not naming your new 
column, but that's not recommended!
]

.pull-left[
`r emo::ji("x")`

```{r}
catch_data %>%
  summarise(mean(values, na.rm = T))
```
]
.pull-right[
`r emo::ji("white_check_mark")`

```{r}
catch_data %>%
  summarise(mean_catch = mean(values, na.rm = T))
```
]

---

## `group_by` for grouped operations

```{r}
# mean catch for each lake
catch_data %>%
  group_by(lake) %>% #<<
  summarise(mean_catch = mean(values))
```

---

## Calculating frequencies

The following two give the same result, so `count` is simply short for `group_by` then determine frequencies 

.pull-left[
```{r}
catch_data %>%
  group_by(lake) %>%
  summarise(n = n())
```
]
.pull-right[
```{r}
catch_data %>%
  count(lake)
```
]

---

## Multiple summary statistics

`summarise` can be used for multiple summary statistics as well

```{r}
catch_data %>%
  summarise(
    min_catch = min(values),
    mean_catch = mean(values),
    median_catch = median(values),
    max_catch = max(values)
    )
```

---

.your-turn[
### Your turn!

- Go back to RStudio Cloud and continue `e-04-great-lakes-catches`.
- Open the R Markdown document and complete Exercises 7 - 10.
]
---

.center[
.large[
This class content was built from the Data Science in a Box source materials.
https://datasciencebox.org/index.html
]
]